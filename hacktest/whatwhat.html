<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>tracking.js - draw something</title>
	<link rel="stylesheet" href="assets/demo.css">

	<script src="tracking.js"></script>
	<script src="assets/splines.min.js"></script>
	<script src="assets/stats.min.js"></script>

	<style>
		#canvas,
		#video {
			height: 300px;
			position: absolute;
			width: 400px;
			padding-top: 66px;
		}
		.draw-frame {
			background: url(assets/draw_frame.png);
			width: 400px;
			height: 414px;
			border: 1px solid #ccc;
			top: 50%;
			left: 50%;
			position: absolute;
			margin: -207px 0 0 -200px;
		}

		canvas, video {
			-moz-transform: scale(-1, 1);
			-o-transform: scale(-1, 1);
			-webkit-transform: scale(-1, 1);
			filter: FlipH;
			transform: scale(-1, 1);
		}
	</style>
</head>
<body>

	<div class="demo-title">
		<p><a href="http://trackingjs.com" target="_parent">tracking.js</a> Ôºç use magenta color to draw and cyan to erase</p>
	</div>

	<div class="demo-frame">
		<div class="demo-container">
			<div class="draw-frame">
				<video id="video" width="400" height="300" preload autoplay loop muted></video>
				<canvas id="canvas" width="400" height="300"></canvas>
			</div>
		</div>
	</div>

	<script>
		window.onload = function() {
			var video = document.getElementById('video');
			var canvas = document.getElementById('canvas');
			var context = canvas.getContext('2d');

			// var drawSegments = [[]];
			var rects = []

			tracking.ColorTracker.registerColor('mypink', function(r, g, b) {
				var threshold = 50,
				dx = r - 255,
				dy = g - 50,
				dz = b - 255;
				if ((r - g) >= threshold && (b - g) >= threshold) {
					return true;
				}
				return dx * dx + dy * dy + dz * dz < 19600;
			});

			var tracker = new tracking.ColorTracker(['mypink']);

			tracking.track('#video', tracker, { camera: true });

			tracker.on('track', function(event) {
				// if (event.data.length === 0) {
				// 	segment++;

				// 	if (!drawSegments[segment]) {
				// 		drawSegments[segment] = [];
				// 	}
				// }

				

				rects = getBiArr(event.data)

				if (rects.length > 0)
					console.log(rects)

				context.font="14px Arial";
				context.clearRect(0, 0, canvas.width, canvas.height)
				context.beginPath()

				for (var i = 0, len = rects.length; i < len; i++) {
					context.fillText('' + rects[i].row + ', ' + rects[i].col, rects[i].cx, rects[i].cy)

					context.rect(rects[i].x, rects[i].y, rects[i].width, rects[i].height)
				}
				context.closePath()
				context.stroke()

		// console.log(event.data)

		// event.data.forEach(function(rect) {
		//   if (rect.color === 'magenta') {
		//     //console.log(rect)
		//     draw(rect);
		//   }
		// });
		});

		var testDataArr = [
		{"width":36,"height":41,"x":201,"y":99,"color":"magenta"},
		{"width":31,"height":32,"x":145,"y":106,"color":"magenta"},
		{"width":43,"height":53,"x":138,"y":160,"color":"magenta"},
		{"width":34,"height":53,"x":207,"y":168,"color":"magenta"},
		{"width":42,"height":50,"x":276,"y":261,"color":"magenta"},
		{"width":34,"height":40,"x":213,"y":263,"color":"magenta"}]


		var biArr = getBiArr(testDataArr)

		function getBiArr(inData) {
			if (inData.length === 0)
				return inData

			var processedData = []
			var toProcess = []

			// Add useful properties and flags
			for (var i = 0; i < inData.length; i++) {
				inData[i].cx = inData[i].width / 2 + inData[i].x
				inData[i].cy = inData[i].height / 2 + inData[i].y

				inData[i].row = null
				inData[i].col = null

				inData[i]._id = i
			}

			inData[0].row = 0
			inData[0].col = 0
			
			toProcess.push(inData.splice(0, 1)[0])

			console.log(toProcess)

			while (toProcess.length > 0 && inData.length > 0) {
				var curr = toProcess.shift()
				processedData.push(curr)

				var sameColumn = [curr]
				var sameRow = [curr]

				// Get the elemetns that are on the same column or on the same row
					inData.forEach(function(elem){
						if (isOnSameColumn(curr, elem))
							sameColumn.push(elem)

						if (isOnSameRow(curr, elem))
							sameRow.push(elem)
					})

				// Sort columns and then rows based on their order
					sameColumn.sort(function(colSmall, colBig) {
						return colSmall.cy > colBig.cy
					})

					sameRow.sort(function(rowSmall, rowBig) {
						return rowSmall.cx > rowBig.cx
					})

				// Check if the distance between consecutive elements isn't too big
				cutGapsInSameColumn(sameColumn, sameColumn.indexOf(curr))
				cutGapsInSameRow(sameRow, sameRow.indexOf(curr))

				// Set the column and row number
				currIndexCol = sameColumn.indexOf(curr)
				currIndexRow = sameRow.indexOf(curr)

				sameColumn.forEach(function(elem, index) {
					elem.row = index - currIndexCol + curr.row
					elem.col = curr.col
				})

				sameRow.forEach(function(elem, index){
					elem.row = curr.row
					elem.col = index - currIndexRow + curr.col
				})

				// Remove semi-processed elements from inData
				var i = 0
				while (i < inData.length) {
					if (inData[i].row != null) // or col==null
						inData.splice(i, 1)
					else
						i ++
				}

				// Add elements from sameRow and sameColumn to be processed further
				sameColumn.splice(currIndexCol, 1)
				sameRow.splice(currIndexRow, 1)
				toProcess = toProcess.concat(sameColumn).concat(sameRow)
			}

			processedData = processedData.concat(toProcess)

			// Makes smallest column equal to 0
			var smallestCol = 9001
			var smallestRow = 9001

			// Find Smallest col and row
			processedData.forEach(function (elem) {
				if (elem.col < smallestCol)
					smallestCol = elem.col
			
				if (elem.row < smallestRow)
					smallestRow = elem.row
			})

			// Set things up
			processedData.forEach(function (elem) {
				elem.col -= smallestCol
				elem.row -= smallestRow
			})

			return processedData
		}

		function cutGapsInSameColumn(sameColumn, currIndexCol) {
			for (var i = currIndexCol; i < sameColumn.length-1; i++) {
				if ((sameColumn[i+1].cy - sameColumn[i].cy) > sameColumn[i+1].height * 3) {
					sameColumn.splice(i+1)
					break
				}
			}

			for (var i = 0; i < currIndexCol-1; i++) {
				if ((sameColumn[i+1].cy - sameColumn[i].cy) > sameColumn[i+1].height * 3) {
					sameColumn.splice(0, i+1)
					break
				}
			}
		}

		function cutGapsInSameRow(sameRow, currIndexRow) {
			for (var i = currIndexRow; i < sameRow.length-1; i++) {
				if ((sameRow[i+1].cx - sameRow[i].cx) > sameRow[i+1].width * 3) {
					sameRow.splice(i+1)
					break
				}
			}

			for (var i = 0; i < currIndexRow-1; i++) {
				if ((sameRow[i+1].cx - sameRow[i].cx) > sameRow[i+1].width * 3) {
					sameRow.splice(0, i+1)
					break
				}
			}
		}

		function isBetween (num, small, big) {
			return num >= small && num <= big
		}

		function isOnSameColumn (stableRect, controlRect) {
			return isBetween(controlRect.cx, stableRect.x, stableRect.x + stableRect.width)
		}

		function isOnSameRow (stableRect, controlRect) {
			return isBetween(controlRect.cy, stableRect.y, stableRect.y + stableRect.height)
		}




	// (function loop() {
	// 	requestAnimationFrame(loop);
	// }());
};
</script>

</body>
</html>
