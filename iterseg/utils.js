// Generated by CoffeeScript 1.7.1
var Matrix, NDirec, Point, Utils, Vector, array2D;

Matrix = (function() {
  function Matrix() {
    this.mat = Utils.array1D(9, 0);
    this.temp = Utils.array1D(9, 0);
    this.chg = Utils.array1D(9, 0);
    this.clear();
  }

  Matrix.prototype.clear = function() {
    Utils.unitMatrix3(this.mat);
    return this;
  };

  Matrix.prototype.apply = function(p) {
    return [p[0] * this.mat[0] + p[1] * this.mat[3] + this.mat[6], p[0] * this.mat[1] + p[1] * this.mat[4] + this.mat[7]];
  };

  Matrix.prototype.translate = function(x, y) {
    Utils.unitMatrix3(this.chg);
    this.chg[6] = x;
    this.chg[7] = y;
    Utils.matrix3x3(this.mat, this.chg, this.temp);
    Utils.copyArray(this.temp, this.mat, 9);
    return this;
  };

  Matrix.prototype.rotate = function(th) {
    Utils.unitMatrix3(this.chg);
    this.chg[0] = Math.cos(th);
    this.chg[1] = Math.sin(th);
    this.chg[3] = -Math.sin(th);
    this.chg[4] = Math.cos(th);
    Utils.matrix3x3(this.mat, this.chg, this.temp);
    Utils.copyArray(this.temp, this.mat, 9);
    return this;
  };

  Matrix.prototype.scale = function(x, y) {
    Utils.unitMatrix3(this.chg);
    this.chg[0] = x;
    this.chg[4] = y;
    Utils.matrix3x3(this.mat, this.chg, this.temp);
    Utils.copyArray(this.temp, this.mat, 9);
    return this;
  };

  Matrix.prototype.manual = function(mat) {
    Utils.matrix3x3(this.mat, mat, this.temp);
    Utils.copyArray(this.temp, this.mat, 9);
    return this;
  };

  return Matrix;

})();

Utils = {
  trigPoints: [0, 30, 45, 60, 0 + 90, 30 + 90, 45 + 90, 60 + 90, 0 + 180, 30 + 180, 45 + 180, 60 + 180, 0 + 270, 30 + 270, 45 + 270, 60 + 270, 360],
  setpoly: function(p, arr) {
    return p.attr({
      points: Utils.arrXYToStr(arr)
    });
  },
  closest: function(mid, left, right) {
    if (Math.abs(mid - left) < Math.abs(mid - right)) {
      return left;
    } else {
      return right;
    }
  },
  dist2points: function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  },
  getArrow: function(x1, y1, x2, y2, rad, side) {
    var a, i, nv, _i;
    a = [new Vector(0, -rad), new Vector(0, rad), new Vector(x2, y2)];
    if (side === 1) {
      a[1].y = 0;
    } else {

    }
    if (side === -1) {
      a[0].y = 0;
    }
    nv = new Vector(x2 - x1, y2 - y1);
    for (i = _i = 0; _i < 2; i = _i += 1) {
      a[i].ang += nv.ang;
      a[i].x += x1;
      a[i].y += y1;
    }
    return a;
  },
  arrXYToStr: function(arr) {
    var i, str, _i, _ref;
    str = '';
    for (i = _i = 0, _ref = arr.length; _i < _ref; i = _i += 1) {
      str += ' ' + arr[i].x + ' ' + arr[i].y;
    }
    return str;
  },
  buttonType: function(evt) {
    if (!evt.buttons) {
      switch (evt.which) {
        case 1:
          return 'left';
        case 2:
          return 'middle';
        case 3:
          return 'right';
      }
    } else {
      switch (evt.buttons) {
        case 1:
          return 'left';
        case 4:
          return 'middle';
        case 2:
          return 'right';
      }
    }
    return 'other';
  },
  colors: ['brown', 'green', 'blue', 'red', 'yellow', 'gray', 'magenta', 'rose'],
  toUnitVectors: function(points) {
    var ang, i, len, mat, rad, ret, _i;
    len = points.length;
    ret = [];
    if (len < 2) {
      return;
    }
    ang = Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x);
    rad = this.dist2points(points[0].x, points[0].y, points[1].x, points[1].y);
    mat = (new Matrix()).translate(-points[0].x, -points[0].y).rotate(-ang).scale(1 / rad, 1 / rad);
    for (i = _i = 0; _i < len; i = _i += 1) {
      ret.push(mat.apply([points[i].x, points[i].y]));
    }
    return ret;
  },
  matrix3x3: function(m, t, ret) {
    ret[0] = m[0] * t[0] + m[1] * t[3] + m[2] * t[6];
    ret[1] = m[0] * t[1] + m[1] * t[4] + m[2] * t[7];
    ret[2] = m[0] * t[2] + m[1] * t[5] + m[2] * t[8];
    ret[3] = m[3] * t[0] + m[4] * t[3] + m[5] * t[6];
    ret[4] = m[3] * t[1] + m[4] * t[4] + m[5] * t[7];
    ret[5] = m[3] * t[2] + m[4] * t[5] + m[5] * t[8];
    ret[6] = m[6] * t[0] + m[7] * t[3] + m[8] * t[6];
    ret[7] = m[6] * t[1] + m[7] * t[4] + m[8] * t[7];
    return ret[8] = m[6] * t[2] + m[7] * t[5] + m[8] * t[8];
  },
  array2D: function(rows, cols, init) {
    var i, j, t, _i, _j;
    t = new Array(rows);
    for (i = _i = 0; _i < rows; i = _i += 1) {
      t[i] = new Array(cols);
      for (j = _j = 0; _j < cols; j = _j += 1) {
        t[i][j] = init;
      }
    }
    return t;
  },
  array1D: function(length, init) {
    var i, t, _i;
    t = new Array(length);
    for (i = _i = 0; _i < length; i = _i += 1) {
      t[i] = init;
    }
    return t;
  },
  copyArray: function(from, to, length) {
    while (--length >= 0) {
      to[length] = from[length];
    }
  },
  unitMatrix3: function(mat) {
    mat[0] = 1;
    mat[1] = 0;
    mat[2] = 0;
    mat[3] = 0;
    mat[4] = 1;
    mat[5] = 0;
    mat[6] = 0;
    mat[7] = 0;
    return mat[8] = 1;
  },
  listFromArray: function(graph, func) {
    var i, j, list, _i, _j, _ref, _ref1;
    list = [];
    for (i = _i = 0, _ref = graph.length; _i < _ref; i = _i += 1) {
      for (j = _j = 0, _ref1 = graph[i].length; _j < _ref1; j = _j += 1) {
        if (func(graph[i][j])) {
          list.push(new NDirec(i, j));
        }
      }
    }
    return list;
  },
  random1Vec: function() {
    var v;
    v = new Vector();
    v.ang = Math.random() * Math.PI * 2;
    v.rad = Math.random();
    return v;
  }
};

Point = (function() {
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  return Point;

})();

Vector = (function() {
  function Vector(x, y) {
    this.orthX;
    this.orthY;
    this.polarRad;
    this.polarAng;
    this.setOrtho(x, y);
    Object.defineProperty(this, 'x', {
      get: function() {
        return this.orthX;
      },
      set: function(val) {
        this.orthX = val;
        this.recalcPolar();
      }
    });
    Object.defineProperty(this, 'y', {
      get: function() {
        return this.orthY;
      },
      set: function(val) {
        this.orthY = val;
        this.recalcPolar();
      }
    });
    Object.defineProperty(this, 'rad', {
      get: function() {
        return this.polarRad;
      },
      set: function(val) {
        this.polarRad = val;
        this.recalcOrtho();
      }
    });
    Object.defineProperty(this, 'ang', {
      get: function() {
        return this.polarAng;
      },
      set: function(val) {
        this.polarAng = val;
        this.recalcOrtho();
      }
    });
  }

  Vector.prototype.show = function() {
    console.log(this.orthX + ' ' + this.orthY);
  };

  Vector.prototype.getSimpleOrtho = function() {
    return {
      x: this.orthX,
      y: this.orthY
    };
  };

  Vector.prototype.getSimplePolar = function() {
    return {
      rad: this.polarRad,
      ang: this.polarAng
    };
  };

  Vector.prototype.recalcOrtho = function() {
    this.orthX = Math.cos(this.polarAng) * this.polarRad;
    return this.orthY = Math.sin(this.polarAng) * this.polarRad;
  };

  Vector.prototype.recalcPolar = function() {
    this.polarRad = Math.sqrt(this.orthX * this.orthX + this.orthY * this.orthY);
    return this.polarAng = Math.atan2(this.orthY, this.orthX);
  };

  Vector.prototype.rotate = function(nang, nx, ny) {
    var oldx, oldy;
    oldx = this.orthX;
    oldy = this.orthY;
    this.orthX = nx + (oldx - nx) * Math.cos(nang) - (oldy - ny) * Math.sin(nang);
    this.orthY = ny + (oldx - nx) * Math.sin(nang) + (oldy - ny) * Math.cos(nang);
    this.recalcPolar();
  };

  Vector.prototype.setOrtho = function(x, y) {
    if (arguments.length === 1) {
      this.orthX = x.x;
      this.orthY = x.y;
    } else {
      this.orthX = x || 0;
      this.orthY = y || 0;
    }
    this.recalcPolar();
  };

  Vector.prototype.setPolar = function(rad, ang) {
    this.polarRad = rad || 0;
    this.polarAng = ang || 0;
    return this.recalcOrtho();
  };

  return Vector;

})();

NDirec = (function() {
  function NDirec(from, to) {
    this.from = from;
    this.to = to;
  }

  return NDirec;

})();

array2D = function(rows, cols) {
  var i, j, t, _i, _j;
  t = new Array(rows);
  for (i = _i = 0; _i < rows; i = _i += 1) {
    t[i] = new Array(cols);
    for (j = _j = 0; _j < cols; j = _j += 1) {
      t[i][j] = 0;
    }
  }
  return t;
};
